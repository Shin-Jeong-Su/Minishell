cat <<hi <a 릭 해결
$a 해결.
cat $a 해결.
cat < $a 해결.
echo $a $USER 해결.
cat <a <b <c <d <e <f <<hi 릭체크 해결.
cat <a <b <c <<hi <f  해결.
cat <a <b | ls 해결.
$? ctrl+c 해결.
----------------------------------------



----------------------------------------
when command not found. $? is not 127.

------------signal 처리 필요---------------
cat <<a <<b | cat <<c <<d interrupt signal 줄때 두번줘야 끝남..,
grep ha ctrl +d 두두번번받받음음
ctrl+\ quit해야함
interactive mode에서 quit되어야함.ctlr +\

-------------------------
Study need to.
interective mode가 무엇?
reentrant meaning
Program counter, resister, about Context.
subroutine
signal blocking : internal, external.
global valuable valatile. 
how does a compiler optimize a extern?
link time optimization
compiler optimization
--------------------------
echo >|cat : 실행안됨. 근데 배쉬는 됨. >| overwirte하는 기호라서 되는 것. > | 는 신택스가맞음.

-------------얘기해야할것-------------
1. echo <| 를 하면 |노드에도 258이 들어가고 <에도 258이 들어가는데, 순회를 파이프노드부터 순회하니까 다음 newline error을 출력하게 됨.
현재는 check_buf에서 파싱한거에서 에러처리하는데 만약 cat <<a <|와 같이 들어오면 newline 에러를 출력함.

2. 
cat <<hi | 를 입력하고 이후에 
zz
asdf
hi 와 같이 입력하면 segfault가 뜸; 
세그폴트가 나는 이유 : bash에서는 cat <<hi |가 들어왔을 때 heredoc부터 받고 그다음에 명령을 추가로 받는다.
현재는 세그폴트가 뜨지 않게만 처리해놨음.
그런데 저렇게 들어왔을 때 뒤 파이프 라인을 받지 않고 히어독을 처리한다음 커맨드 실행파트로 넘어가기 때문에 없는것을 실행하려 참조하다가 세그폴트가 나는 것. 
트리만드는 단계에서 히어독이 있는지 추가 커맨드를 받아야 하는지를 확인하는 게 좋을 것 같음. 히어독이 있다면 히어독 먼저 받고 추가 커맨드를 받아야하면 추가커맨드를 받고
그리고 나서 트리를 만들어서 트리를 가지고 실행하는 것.